{
  "status": 0,
  "result": {
    "records": [
      {
        "attributes": {
          "type": "ApexClass",
          "url": "/services/data/v65.0/tooling/sobjects/ApexClass/01pQH00000HfbbeYAB"
        },
        "Body": "/**\n * @description Stage 8: Prompt Assembly\n * Builds complete prompt command with AI instructions, integrates HTML template,\n * adds grounding rules, and validates all merge fields\n */\npublic without sharing class Stage08_PromptAssembly implements IStage {\n\n    private static final Integer STAGE_NUMBER = 8;\n\n    /**\n     * @description Executes Stage 8: Prompt Assembly\n     * @param runId ID of the PF_Run__c record\n     * @param inputs Map containing HTML template and configuration from previous stages\n     * @return StageResult with assembled prompt configuration in outputs\n     */\n    public StageResult execute(Id runId, Map<String, Object> inputs) {\n        StageResult result = new StageResult('Stage 8: Prompt Assembly');\n        // Don't store inputs - causes stack overflow during serialization\n        // result.inputs = inputs;\n\n        try {\n            // Use deferred logging (no DML) - logs will be inserted later\n            result.queueInfo(runId, STAGE_NUMBER, 'Starting prompt assembly');\n\n            // Extract inputs\n            String htmlTemplate = (String) inputs.get('htmlTemplate');\n            if (String.isBlank(htmlTemplate)) {\n                throw new StageException('No HTML template provided for prompt assembly');\n            }\n\n            String rootObject = (String) inputs.get('rootObject');\n            String businessContext = (String) inputs.get('businessContext');\n            String targetPersona = (String) inputs.get('targetPersona');\n            Map<String, Object> selectedFieldsRaw = (Map<String, Object>) inputs.get('selectedFields');\n            List<Object> businessObjectivesRaw = (List<Object>) inputs.get('businessObjectives');\n\n            // NEW: Extract Strategic Context from Stage 2\n            // CRITICAL: Use companyIntelligence (actual research) over companyProfile (AI summary)\n            String companyIntelligence = (String) inputs.get('companyIntelligence');\n            String companyProfile = (String) inputs.get('companyProfile');\n            String strategicInsights = (String) inputs.get('strategicInsights');\n            String industryContext = (String) inputs.get('industryContext');\n            \n            // Prefer the actual company research over generic AI summary\n            String effectiveCompanyContext = String.isNotBlank(companyIntelligence) ? companyIntelligence : companyProfile;\n            \n            // Log what company context we're using\n            if (String.isNotBlank(companyIntelligence)) {\n                String preview = companyIntelligence.length() > 100 ? companyIntelligence.substring(0, 100) + '...' : companyIntelligence;\n                result.queueInfo(runId, STAGE_NUMBER, 'Using company research: ' + preview);\n            } else if (String.isNotBlank(companyProfile)) {\n                result.queueInfo(runId, STAGE_NUMBER, 'Using company profile (no direct research available)');\n            }\n\n            result.queueInfo(runId, STAGE_NUMBER, 'Assembling prompt for ' + rootObject);\n\n            // Validate merge fields against selected fields\n            List<MergeFieldValidator.MergeField> validatedFields =\n                validateMergeFieldsDeferred(htmlTemplate, selectedFieldsRaw, rootObject, runId, result);\n\n            // Check for validation failures\n            Integer invalidFieldCount = 0;\n            List<String> validationErrors = new List<String>();\n            for (MergeFieldValidator.MergeField field : validatedFields) {\n                if (!field.isValid) {\n                    invalidFieldCount++;\n                    validationErrors.add(field.originalText + ': ' + field.errorMessage);\n                }\n            }\n\n            if (invalidFieldCount > 0) {\n                result.queueError(runId, STAGE_NUMBER,\n                    invalidFieldCount + ' invalid merge fields detected');\n                for (String error : validationErrors) {\n                    result.queueError(runId, STAGE_NUMBER, error);\n                }\n            }\n\n            // Build AI instructions with REAL company research\n            String aiInstructions = buildAIInstructions(\n                businessContext, targetPersona, businessObjectivesRaw, rootObject,\n                effectiveCompanyContext, strategicInsights, industryContext, runId);\n\n            // Build grounding rules\n            String groundingRules = buildGroundingRules(rootObject, targetPersona);\n\n            // Assemble complete prompt configuration\n            Map<String, Object> promptConfig = assemblePromptConfiguration(\n                aiInstructions, htmlTemplate, groundingRules, rootObject);\n\n            // Build assembly summary\n            String assemblySummary = buildAssemblySummary(\n                aiInstructions, htmlTemplate, groundingRules, validatedFields);\n\n            result.queueInfo(runId, STAGE_NUMBER, assemblySummary);\n\n            // Build DCM config for Stage 9\n            Map<String, Object> dcmConfig = buildDCMConfigForStage9(\n                rootObject, selectedFieldsRaw, inputs);\n\n            // Build Prompt config for Stage 9\n            Map<String, Object> promptConfigForStage9 = buildPromptConfigForStage9(\n                rootObject, aiInstructions, htmlTemplate, groundingRules, inputs);\n\n            // Build outputs - include dcmConfig and promptConfig for Stage 9\n            result.outputs.put('dcmConfig', dcmConfig);\n            result.outputs.put('promptConfig', promptConfigForStage9);\n            result.outputs.put('promptConfiguration', promptConfig);\n            result.outputs.put('aiInstructions', aiInstructions);\n            result.outputs.put('groundingRules', groundingRules);\n            result.outputs.put('validatedFields', validatedFields);\n            result.outputs.put('invalidFieldCount', invalidFieldCount);\n            result.outputs.put('validationErrors', validationErrors);\n            result.outputs.put('assemblySummary', assemblySummary);\n\n            // Pass through critical inputs for downstream stages\n            result.outputs.put('rootObject', rootObject);\n            result.outputs.put('businessContext', businessContext);\n            result.outputs.put('targetPersona', targetPersona);\n            result.outputs.put('businessObjectives', businessObjectivesRaw);\n            result.outputs.put('htmlTemplate', htmlTemplate);\n            result.outputs.put('selectedFields', selectedFieldsRaw);\n            result.outputs.put('promptName', inputs.get('promptName'));\n            result.outputs.put('sampleRecordId', inputs.get('sampleRecordId'));\n            // Pass through selectedGrandchildren - already used in buildDCMConfigForStage9\n            result.outputs.put('selectedGrandchildren', inputs.get('selectedGrandchildren'));\n\n            // CRITICAL: Fail if ANY invalid merge fields detected\n            // This prevents creating DCM/Prompt with mismatched field references\n            // Mirrors the shell script behavior: fail fast if whitelist validation fails\n            if (invalidFieldCount > 0) {\n                String errorMsg = 'VALIDATION FAILED: ' + invalidFieldCount + ' invalid merge field(s) detected. ' +\n                    'The HTML template references fields not in the selected fields list. ' +\n                    'Fix: Re-run Stage 7 with proper field whitelist or adjust selected fields.';\n                result.markFailed(errorMsg);\n                result.queueError(runId, STAGE_NUMBER, errorMsg);\n                result.queueError(runId, STAGE_NUMBER, 'Invalid fields: ' + String.join(validationErrors, '; '));\n                return result;\n            }\n\n            result.markCompleted();\n            result.queueInfo(runId, STAGE_NUMBER, 'Prompt assembly completed successfully - all merge fields validated');\n\n        } catch (Exception e) {\n            String errorMsg = 'Failed to complete prompt assembly: ' + e.getMessage();\n            result.markFailed(errorMsg);\n            result.queueError(runId, STAGE_NUMBER, 'Stage execution failed: ' + e.getMessage());\n        }\n\n        return result;\n    }\n\n    /**\n     * @description Validates merge fields in template against selected fields (deferred logging)\n     * @param htmlTemplate HTML template containing merge fields\n     * @param selectedFieldsRaw Map of object to field list\n     * @param rootObject The root Salesforce object\n     * @param runId Run ID for logging\n     * @param result StageResult for deferred logging\n     * @return List of validated merge field objects\n     */\n    private List<MergeFieldValidator.MergeField> validateMergeFieldsDeferred(\n            String htmlTemplate,\n            Map<String, Object> selectedFieldsRaw,\n            String rootObject,\n            Id runId,\n            StageResult result) {\n\n        // Build DCM-like configuration for validation\n        Map<String, Object> dcmConfig = buildDCMConfig(selectedFieldsRaw, rootObject);\n\n        // Validate merge fields\n        List<MergeFieldValidator.MergeField> validatedFields =\n            MergeFieldValidator.validateAgainstDCM(htmlTemplate, dcmConfig);\n\n        result.queueDebug(runId, STAGE_NUMBER,\n            'Validated ' + validatedFields.size() + ' merge fields');\n\n        return validatedFields;\n    }\n\n    /**\n     * @description Builds a DCM-like configuration for merge field validation\n     * @param selectedFieldsRaw Map of object to field list\n     * @param rootObject The root Salesforce object\n     * @return Map with rootObject, childObjects, and fieldsByObject\n     */\n    private Map<String, Object> buildDCMConfig(\n            Map<String, Object> selectedFieldsRaw,\n            String rootObject) {\n\n        List<String> childObjects = new List<String>();\n        Map<String, List<String>> fieldsByObject = new Map<String, List<String>>();\n\n        for (String objectName : selectedFieldsRaw.keySet()) {\n            List<Object> fieldsRaw = (List<Object>) selectedFieldsRaw.get(objectName);\n            List<String> fields = new List<String>();\n\n            for (Object field : fieldsRaw) {\n                fields.add(String.valueOf(field));\n            }\n\n            fieldsByObject.put(objectName, fields);\n\n            if (objectName != rootObject) {\n                childObjects.add(objectName);\n            }\n        }\n\n        return new Map<String, Object>{\n            'rootObject' => rootObject,\n            'childObjects' => childObjects,\n            'fieldsByObject' => fieldsByObject\n        };\n    }\n\n    /**\n     * @description Builds AI instructions for the prompt\n     * Includes comprehensive GPTfy output rules, styling requirements, and data handling\n     * Matches the shell script prompt structure for consistent, high-quality output\n     * @param businessContext User-provided business requirements\n     * @param targetPersona Target user persona\n     * @param businessObjectivesRaw List of business objectives\n     * @param rootObject The root Salesforce object\n     * @return Formatted AI instructions string\n     */\n    private String buildAIInstructions(\n            String businessContext,\n            String targetPersona,\n            List<Object> businessObjectivesRaw,\n            String rootObject,\n            String companyProfile,\n            String strategicInsights,\n            String industryContext,\n            Id runId) {\n\n        String instructions = 'You are a Salesforce AI assistant generating HTML content for GPTfy.\\n\\n';\n\n        // === CRITICAL OUTPUT RULES ===\n        instructions += '=== CRITICAL OUTPUT RULES (GPTfy Runtime Validation) ===\\n\\n';\n\n        instructions += 'Rule 1 - SINGLE LINE: Output MUST be a single line with NO newline characters.\\n';\n        instructions += '  WHY: GPTfy stores output as a single field value. Line breaks cause parsing issues.\\n\\n';\n\n        instructions += 'Rule 2 - NO STYLE BLOCKS: Do NOT include any style tags.\\n';\n        instructions += '  WHY: GPTfy renders in Salesforce Lightning which strips style blocks. Only inline styles work.\\n\\n';\n\n        instructions += 'Rule 3 - NO CSS CLASSES: Do NOT use class attributes.\\n';\n        instructions += '  WHY: Without style blocks, CSS classes have no definitions and elements remain unstyled.\\n\\n';\n\n        instructions += 'Rule 4 - NO SCRIPT TAGS: Do NOT include any JavaScript.\\n';\n        instructions += '  WHY: Scripts are a security risk and are stripped by Salesforce Lightning.\\n\\n';\n\n        instructions += 'Rule 5 - NO MARKDOWN: Do NOT wrap output in code blocks or use markdown formatting.\\n';\n        instructions += '  WHY: Output must be raw HTML, not markdown.\\n\\n';\n\n        instructions += 'Rule 6 - START WITH DIV STYLE: Output MUST begin with a div element with inline style attribute.\\n';\n        instructions += '  WHY: Ensures proper container structure with inline styles.\\n\\n';\n\n        instructions += 'Rule 7 - END WITH DIV: Output MUST end with a closing div tag.\\n';\n        instructions += '  WHY: Ensures HTML structure is complete and properly closed.\\n\\n';\n\n        instructions += 'Rule 8 - NO PLACEHOLDERS: Never output bracket-X patterns, placeholder text, TBD, TODO, or similar.\\n';\n        instructions += '  WHY: Indicates the prompt didn\\'t properly integrate real data.\\n\\n';\n\n        instructions += 'Rule 9 - NO NULL VALUES: Never output null, undefined, or Not Available in visible text.\\n';\n        instructions += '  WHY: Missing data should be handled gracefully by omitting the section.\\n\\n';\n\n        instructions += 'Rule 10 - NO EMOJIS: Do NOT use any emoji characters.\\n';\n        instructions += '  WHY: Professional business content should not contain emojis.\\n\\n';\n\n        // === STYLING REQUIREMENTS ===\n        instructions += '=== STYLING REQUIREMENTS (Salesforce Brand) ===\\n\\n';\n\n        instructions += 'Font: \\'Salesforce Sans\\', -apple-system, BlinkMacSystemFont, \\'Segoe UI\\', Roboto, Arial, sans-serif\\n';\n        instructions += 'Base Size: 14px\\n\\n';\n\n        instructions += 'Colors:\\n';\n        instructions += '- Primary Blue: #0176D3\\n';\n        instructions += '- Dark Blue: #014486\\n';\n        instructions += '- Success Green: #2E844A\\n';\n        instructions += '- Warning Orange: #DD7A01\\n';\n        instructions += '- Error Red: #BA0517\\n';\n        instructions += '- Text Primary: #181818\\n';\n        instructions += '- Text Secondary: #706E6B\\n';\n        instructions += '- Background: #F3F3F3\\n';\n        instructions += '- Card Background: #FFFFFF\\n';\n        instructions += '- Border: #DDDBDA\\n\\n';\n\n        instructions += 'Components:\\n';\n        instructions += '- Cards: white background, 8px border-radius, 1px solid border in DDDBDA color, 16px padding\\n';\n        instructions += '- Headers: linear gradient from Primary Blue to Dark Blue, white text, 16px padding\\n';\n        instructions += '- Progress bars: 8px height, DDDBDA background, colored fill based on score\\n';\n        instructions += '- Status badges: 4px 12px padding, 4px border-radius, semantic color background\\n';\n        instructions += '- Tables: border-collapse, F3F3F3 header background, 10px 12px cell padding\\n\\n';\n\n        // === DATA HANDLING ===\n        instructions += '=== DATA HANDLING ===\\n\\n';\n        instructions += '- If a merge field returns empty or null, OMIT that section entirely - do not show empty labels\\n';\n        instructions += '- Use relative timeframes in recommendations (this week, within 3 days) not absolute dates\\n';\n        instructions += '- All merge fields are provided using triple-brace syntax and will be substituted by GPTfy at runtime\\n';\n\n        // === BUSINESS CONTEXT ===\n        instructions += 'Generate a premium, executive-style dashboard for: ' + targetPersona + '\\n\\n';\n\n        // === STRATEGIC CONTEXT (Account 360) ===\n        if (String.isNotBlank(companyProfile) || String.isNotBlank(strategicInsights) || String.isNotBlank(industryContext)) {\n             instructions += '=== STRATEGIC CONTEXT (Account 360) ===\\n';\n             instructions += 'Use this intelligence to make the content highly relevant and personalized.\\n\\n';\n             \n             if (String.isNotBlank(companyProfile)) {\n                 instructions += 'COMPANY PROFILE:\\n' + companyProfile + '\\n\\n';\n             }\n             if (String.isNotBlank(industryContext)) {\n                 instructions += 'INDUSTRY CONTEXT:\\n' + industryContext + '\\n\\n';\n             }\n             if (String.isNotBlank(strategicInsights)) {\n                 instructions += 'STRATEGIC INSIGHTS:\\n' + strategicInsights + '\\n\\n';\n             }\n        }\n\n        // Include full business context from user input\n        if (String.isNotBlank(businessContext)) {\n            instructions += 'SPECIFIC REQUIREMENTS:\\n' + businessContext + '\\n\\n';\n        }\n\n        if (businessObjectivesRaw != null && !businessObjectivesRaw.isEmpty()) {\n            instructions += 'Business Goals: ';\n            List<String> objectives = new List<String>();\n            for (Object obj : businessObjectivesRaw) {\n                objectives.add(String.valueOf(obj));\n            }\n            instructions += String.join(objectives, ', ') + '\\n\\n';\n        }\n\n        // === CRITICAL: ANALYSIS REQUIREMENTS ===\n        instructions += '=== CRITICAL: ANALYSIS REQUIREMENTS ===\\n\\n';\n        instructions += 'You are NOT just displaying data - you are providing INTELLIGENT BUSINESS ANALYSIS.\\n';\n        instructions += 'The template below contains merge fields that will be replaced with real Salesforce data.\\n';\n        instructions += 'Your job is to ANALYZE this data and provide ACTIONABLE INSIGHTS.\\n\\n';\n        \n        instructions += 'ANALYSIS YOU MUST PERFORM:\\n\\n';\n        \n        instructions += '1. OPPORTUNITY HEALTH ANALYSIS:\\n';\n        instructions += '   - Identify stale opportunities (close dates in the past or soon)\\n';\n        instructions += '   - Flag deals stuck in early stages for too long\\n';\n        instructions += '   - Calculate total pipeline value and weighted pipeline\\n';\n        instructions += '   - Recommend next steps for each opportunity\\n\\n';\n        \n        instructions += '2. CASE/SUPPORT RISK ANALYSIS:\\n';\n        instructions += '   - Flag high-priority open cases that need attention\\n';\n        instructions += '   - Identify aging cases (open for extended periods)\\n';\n        instructions += '   - Calculate customer satisfaction risk based on case patterns\\n';\n        instructions += '   - Recommend resolution priorities\\n\\n';\n        \n        instructions += '3. ENGAGEMENT PATTERN ANALYSIS:\\n';\n        instructions += '   - Identify last contact date and engagement gaps\\n';\n        instructions += '   - Flag accounts with no recent activity (going cold)\\n';\n        instructions += '   - Analyze contact coverage (do we have the right stakeholders?)\\n';\n        instructions += '   - Recommend engagement actions\\n\\n';\n        \n        instructions += '4. EXECUTIVE SUMMARY:\\n';\n        instructions += '   - Provide an overall account health score or assessment\\n';\n        instructions += '   - List top 3 priorities for this account\\n';\n        instructions += '   - Identify the biggest risk and biggest opportunity\\n';\n        instructions += '   - Recommend immediate actions\\n\\n';\n        \n        instructions += 'OUTPUT STRUCTURE:\\n';\n        instructions += 'Your output should include BOTH the templated data AND your analytical sections.\\n';\n        instructions += 'Add analysis sections with headers like \"Executive Summary\", \"Key Risks\", \"Recommended Actions\".\\n';\n        instructions += 'Do NOT just render tables - add CONTEXT and INTERPRETATION before/after data sections.\\n\\n';\n        \n        instructions += 'The output should be visually stunning, data-rich, and immediately actionable.\\n';\n        instructions += 'Use ONLY the merge field embeddings provided in the template below. Do not add or modify merge fields.\\n';\n        instructions += 'Merge fields use triple-brace syntax and will be substituted by GPTfy at runtime.\\n\\n';\n\n        PromptFactoryLogger.info(runId, 8, 'üèóÔ∏è BUILD AI INSTRUCTIONS: Starting builder injection');\n        Integer initialLength = instructions.length();\n        \n        // NEW: Load and inject Builder Prompts\n        PromptFactoryLogger.info(runId, 8, 'üìã Step 1: Loading Quality Rules');\n        String qualityRules = loadQualityRules(runId);\n        if (String.isNotBlank(qualityRules)) {\n            instructions += qualityRules + '\\n\\n';\n            PromptFactoryLogger.info(runId, 8, '‚úÖ Injected Quality Rules: +' + qualityRules.length() + ' chars');\n        } else {\n            PromptFactoryLogger.warning(runId, 8, '‚ö†Ô∏è No Quality Rules to inject');\n        }\n\n        PromptFactoryLogger.info(runId, 8, 'üìã Step 2: Loading Patterns');\n        String patterns = loadPatterns(rootObject, runId);\n        if (String.isNotBlank(patterns)) {\n            instructions += patterns + '\\n\\n';\n            PromptFactoryLogger.info(runId, 8, '‚úÖ Injected Patterns: +' + patterns.length() + ' chars');\n        } else {\n            PromptFactoryLogger.warning(runId, 8, '‚ö†Ô∏è No Patterns to inject');\n        }\n\n        // NEW: Load and inject UI Components\n        PromptFactoryLogger.info(runId, 8, 'üìã Step 3: Loading UI Components');\n        String uiComponents = loadUIComponents(runId);\n        if (String.isNotBlank(uiComponents)) {\n            instructions += uiComponents + '\\n\\n';\n            PromptFactoryLogger.info(runId, 8, '‚úÖ Injected UI Components: +' + uiComponents.length() + ' chars');\n        } else {\n            PromptFactoryLogger.warning(runId, 8, '‚ö†Ô∏è No UI Components to inject');\n        }\n\n        // NEW: Load and inject Context Templates\n        PromptFactoryLogger.info(runId, 8, 'üìã Step 4: Loading Context Templates');\n        String contextTemplates = loadContextTemplates(runId);\n        if (String.isNotBlank(contextTemplates)) {\n            instructions += contextTemplates + '\\n\\n';\n            PromptFactoryLogger.info(runId, 8, '‚úÖ Injected Context Templates: +' + contextTemplates.length() + ' chars');\n        } else {\n            PromptFactoryLogger.warning(runId, 8, '‚ö†Ô∏è No Context Templates to inject');\n        }\n        \n        Integer finalLength = instructions.length();\n        Integer addedContent = finalLength - initialLength;\n        PromptFactoryLogger.info(runId, 8, 'üìä BUILDER INJECTION COMPLETE: Added ' + addedContent + ' chars from builders');\n        PromptFactoryLogger.info(runId, 8, 'üìä Total instruction length: ' + finalLength + ' chars');\n\n        return instructions;\n    }\n\n    /**\n     * @description Load active Quality Rules from Builder Prompts\n     * @param runId PF_Run__c ID for logging\n     * @return Combined quality rules content\n     */\n    private String loadQualityRules(Id runId) {\n        try {\n            PromptFactoryLogger.info(runId, 8, 'üîç loadQualityRules() called - using HARDCODED IDs as test');\n            \n            // TEMPORARY: Hardcode builder IDs to test if query is the issue\n            List<ccai__AI_Prompt__c> rules = [\n                SELECT Id, Name, ccai__Prompt_Command__c\n                FROM ccai__AI_Prompt__c\n                WHERE RecordType.DeveloperName = 'Builder'\n                  AND Category__c = 'Quality Rule'\n                  AND ccai__Status__c = 'Active'\n                ORDER BY Name\n            ];\n            \n            PromptFactoryLogger.info(runId, 8, 'üìä Query returned: ' + rules.size() + ' Quality Rules');\n            \n            if (rules.isEmpty()) {\n                PromptFactoryLogger.warning(runId, 8, '‚ö†Ô∏è No Quality Rules found - returning empty');\n                return '';\n            }\n            \n            String allRules = '';\n            for (ccai__AI_Prompt__c rule : rules) {\n                PromptFactoryLogger.info(runId, 8, '‚úÖ Loading: ' + rule.Name + ' (' + rule.ccai__Prompt_Command__c.length() + ' chars)');\n                allRules += '\\n\\n=== ' + rule.Name + ' ===\\n\\n';\n                allRules += rule.ccai__Prompt_Command__c;\n            }\n            \n            PromptFactoryLogger.info(runId, 8, '‚úÖ Loaded ' + rules.size() + ' Quality Rules (' + allRules.length() + ' total chars)');\n            return allRules;\n            \n        } catch (Exception e) {\n            PromptFactoryLogger.error(runId, 8, '‚ùå Error loading Quality Rules: ' + e.getMessage() + ' | Stack: ' + e.getStackTraceString());\n            return '';\n        }\n    }\n\n    /**\n     * @description Load active Patterns from Builder Prompts for specific object\n     * @param rootObject The Salesforce object (e.g., 'Opportunity')\n     * @param runId PF_Run__c ID for logging\n     * @return Combined pattern content\n     */\n    private String loadPatterns(String rootObject, Id runId) {\n        try {\n            PromptFactoryLogger.info(runId, 8, 'üîç loadPatterns() called - using HARDCODED IDs as test');\n            \n            // TEMPORARY: Hardcode builder IDs to test if query is the issue\n            List<ccai__AI_Prompt__c> patterns = [\n                SELECT Id, Name, ccai__Prompt_Command__c\n                FROM ccai__AI_Prompt__c\n                WHERE RecordType.DeveloperName = 'Builder'\n                  AND Category__c = 'Pattern'\n                  AND ccai__Status__c = 'Active'\n                  AND (ccai__Object__c = :rootObject OR ccai__Object__c = null)\n                ORDER BY Name\n            ];\n            \n            PromptFactoryLogger.info(runId, 8, 'üìä Query returned: ' + patterns.size() + ' Patterns');\n            \n            if (patterns.isEmpty()) {\n                PromptFactoryLogger.warning(runId, 8, '‚ö†Ô∏è No Patterns found for ' + rootObject);\n                return '';\n            }\n            \n            String allPatterns = '';\n            for (ccai__AI_Prompt__c pattern : patterns) {\n                PromptFactoryLogger.info(runId, 8, '‚úÖ Loading: ' + pattern.Name + ' (' + pattern.ccai__Prompt_Command__c.length() + ' chars)');\n                allPatterns += '\\n\\n=== ' + pattern.Name + ' ===\\n\\n';\n                allPatterns += pattern.ccai__Prompt_Command__c;\n            }\n            \n            PromptFactoryLogger.info(runId, 8, '‚úÖ Loaded ' + patterns.size() + ' Patterns (' + allPatterns.length() + ' total chars)');\n            return allPatterns;\n            \n        } catch (Exception e) {\n            PromptFactoryLogger.error(runId, 8, '‚ùå Error loading Patterns: ' + e.getMessage() + ' | Stack: ' + e.getStackTraceString());\n            return '';\n        }\n    }\n\n    /**\n     * @description Load active UI Components from Builder Prompts\n     * @param runId PF_Run__c ID for logging\n     * @return Combined UI component content\n     */\n    private String loadUIComponents(Id runId) {\n        try {\n            PromptFactoryLogger.info(runId, 8, 'üîç loadUIComponents() called - using HARDCODED IDs as test');\n            \n            // TEMPORARY: Hardcode builder IDs to test if query is the issue\n            List<ccai__AI_Prompt__c> components = [\n                SELECT Id, Name, ccai__Prompt_Command__c\n                FROM ccai__AI_Prompt__c\n                WHERE RecordType.DeveloperName = 'Builder'\n                  AND Category__c = 'UI Component'\n                  AND ccai__Status__c = 'Active'\n                ORDER BY Name\n            ];\n            \n            PromptFactoryLogger.info(runId, 8, 'üìä Query returned: ' + components.size() + ' UI Components');\n            \n            if (components.isEmpty()) {\n                PromptFactoryLogger.warning(runId, 8, '‚ö†Ô∏è No UI Components found');\n                return '';\n            }\n            \n            String allComponents = '';\n            for (ccai__AI_Prompt__c component : components) {\n                PromptFactoryLogger.info(runId, 8, '‚úÖ Loading: ' + component.Name);\n                allComponents += '\\n\\n=== ' + component.Name + ' ===\\n\\n';\n                allComponents += component.ccai__Prompt_Command__c;\n            }\n            \n            PromptFactoryLogger.info(runId, 8, '‚úÖ Loaded ' + components.size() + ' UI Components (' + allComponents.length() + ' total chars)');\n            return allComponents;\n            \n        } catch (Exception e) {\n            PromptFactoryLogger.error(runId, 8, '‚ùå Error loading UI Components: ' + e.getMessage());\n            return '';\n        }\n    }\n\n    /**\n     * @description Load active Context Templates from Builder Prompts\n     * @param runId PF_Run__c ID for logging\n     * @return Combined context template content\n     */\n    private String loadContextTemplates(Id runId) {\n        try {\n            PromptFactoryLogger.info(runId, 8, 'üîç loadContextTemplates() called - using HARDCODED IDs as test');\n            \n            // TEMPORARY: Hardcode builder IDs to test if query is the issue\n            List<ccai__AI_Prompt__c> templates = [\n                SELECT Id, Name, ccai__Prompt_Command__c\n                FROM ccai__AI_Prompt__c\n                WHERE RecordType.DeveloperName = 'Builder'\n                  AND Category__c = 'Context Template'\n                  AND ccai__Status__c = 'Active'\n                ORDER BY Name\n            ];\n            \n            PromptFactoryLogger.info(runId, 8, 'üìä Query returned: ' + templates.size() + ' Context Templates');\n            \n            if (templates.isEmpty()) {\n                PromptFactoryLogger.warning(runId, 8, '‚ö†Ô∏è No Context Templates found');\n                return '';\n            }\n            \n            String allTemplates = '';\n            for (ccai__AI_Prompt__c template : templates) {\n                PromptFactoryLogger.info(runId, 8, '‚úÖ Loading: ' + template.Name);\n                allTemplates += '\\n\\n=== ' + template.Name + ' ===\\n\\n';\n                allTemplates += template.ccai__Prompt_Command__c;\n            }\n            \n            PromptFactoryLogger.info(runId, 8, '‚úÖ Loaded ' + templates.size() + ' Context Templates (' + allTemplates.length() + ' total chars)');\n            return allTemplates;\n            \n        } catch (Exception e) {\n            PromptFactoryLogger.error(runId, 8, '‚ùå Error loading Context Templates: ' + e.getMessage());\n            return '';\n        }\n    }\n\n    /**\n     * @description Builds grounding rules for consistent AI behavior\n     * Simplified since main rules are now in AI instructions\n     * @param rootObject The root Salesforce object\n     * @param targetPersona Target user persona\n     * @return Formatted grounding rules string\n     */\n    private String buildGroundingRules(String rootObject, String targetPersona) {\n        // NOTE: GPTfy substitutes all merge fields BEFORE sending to AI.\n        // The AI receives the prompt with real data values already filled in.\n        // Main output rules are in AI instructions - these are supplementary behavioral rules.\n        String rules = '--- GROUNDING RULES ---\\n';\n        rules += '**Grounding Rules:**\\n\\n';\n\n        rules += '1. **Accuracy:** Use ONLY data from the provided ' + rootObject + ' record. Never fabricate company names or contact details.\\n';\n        rules += '2. **Tone:** Maintain a professional, enterprise-appropriate tone for ' + targetPersona + '.\\n';\n        rules += '3. **Format:** Preserve the HTML structure with inline styles. Do NOT use CSS classes.\\n';\n        rules += '4. **Consistency:** Use consistent date formats (MM/DD/YYYY), currency formats ($X,XXX), and terminology.\\n';\n        rules += '5. **Relevance:** Focus on insights that align with the business objectives.\\n';\n        rules += '6. **ANALYZE AND INTERPRET:** Go beyond raw data display. Identify patterns, risks, opportunities, and provide actionable recommendations.\\n';\n\n        return rules;\n    }\n\n    /**\n     * @description Assembles the complete prompt configuration\n     * Mirrors shell script structure: AI Instructions ‚Üí Grounding Rules ‚Üí HTML Template\n     * @param aiInstructions AI instructions section\n     * @param htmlTemplate HTML template with merge fields\n     * @param groundingRules Grounding rules for AI behavior\n     * @param rootObject The root Salesforce object\n     * @return Map containing the complete prompt configuration\n     */\n    private Map<String, Object> assemblePromptConfiguration(\n            String aiInstructions,\n            String htmlTemplate,\n            String groundingRules,\n            String rootObject) {\n\n        // Build the complete prompt text matching shell script structure:\n        // 1. AI Instructions (with output rules, styling, data handling)\n        // 2. Grounding Rules\n        // 3. HTML Template section\n        String completePrompt = aiInstructions;\n        completePrompt += '\\n\\n' + groundingRules;\n        completePrompt += '\\n\\n--- HTML TEMPLATE ---\\n';\n        completePrompt += htmlTemplate;\n\n        Map<String, Object> config = new Map<String, Object>{\n            'promptText' => completePrompt,\n            'aiInstructions' => aiInstructions,\n            'groundingRules' => groundingRules,\n            'htmlTemplate' => htmlTemplate,\n            'rootObject' => rootObject,\n            'version' => '1.0',\n            'createdDate' => System.now().format()\n        };\n\n        return config;\n    }\n\n    /**\n     * @description Builds a human-readable assembly summary\n     * @param aiInstructions AI instructions section\n     * @param htmlTemplate HTML template\n     * @param groundingRules Grounding rules section\n     * @param validatedFields List of validated merge fields\n     * @return Formatted summary string\n     */\n    private String buildAssemblySummary(\n            String aiInstructions,\n            String htmlTemplate,\n            String groundingRules,\n            List<MergeFieldValidator.MergeField> validatedFields) {\n\n        Integer instructionsLength = aiInstructions.length();\n        Integer templateLength = htmlTemplate.length();\n        Integer rulesLength = groundingRules.length();\n        Integer totalLength = instructionsLength + templateLength + rulesLength;\n\n        Integer validFieldCount = 0;\n        for (MergeFieldValidator.MergeField field : validatedFields) {\n            if (field.isValid) {\n                validFieldCount++;\n            }\n        }\n\n        String summary = 'Prompt assembled: ';\n        summary += totalLength + ' characters total (';\n        summary += 'Instructions: ' + instructionsLength + ', ';\n        summary += 'Template: ' + templateLength + ', ';\n        summary += 'Rules: ' + rulesLength + '), ';\n        summary += validFieldCount + ' of ' + validatedFields.size() + ' merge fields validated';\n\n        return summary;\n    }\n\n    /**\n     * @description Builds DCM configuration for Stage 9\n     * Now supports grandchildren with parentObject field\n     * IMPORTANT: Uses selectedObjects (from Stage 3) to ensure ALL child relationships\n     * are included in DCM, even if they don't have data for the specific sample record.\n     * This ensures DCM Detail records are created for all potential child relationships.\n     * @param rootObject The root Salesforce object\n     * @param selectedFieldsRaw Map of object to field list\n     * @param inputs Full inputs for additional context\n     * @return Map with DCM configuration\n     */\n    private Map<String, Object> buildDCMConfigForStage9(\n            String rootObject,\n            Map<String, Object> selectedFieldsRaw,\n            Map<String, Object> inputs) {\n\n        // Get prompt name from run record or inputs\n        String promptName = (String) inputs.get('promptName');\n        if (String.isBlank(promptName)) {\n            promptName = rootObject + ' Summary DCM';\n        }\n\n        // Get grandchild info from inputs (passed from Stage 3 -> Stage 4 -> Stage 5...)\n        Set<String> grandchildObjectNames = new Set<String>();\n        Map<String, String> grandchildParentMap = new Map<String, String>(); // objectName -> parentObject\n        Map<String, String> grandchildRelFieldMap = new Map<String, String>(); // objectName -> relationshipField\n\n        Object gcRaw = inputs.get('selectedGrandchildren');\n        if (gcRaw != null && gcRaw instanceof List<Object>) {\n            for (Object gcObj : (List<Object>) gcRaw) {\n                if (gcObj instanceof Map<String, Object>) {\n                    Map<String, Object> gcMap = (Map<String, Object>) gcObj;\n                    String objName = (String) gcMap.get('objectName');\n                    grandchildObjectNames.add(objName);\n                    grandchildParentMap.put(objName, (String) gcMap.get('parentObject'));\n                    grandchildRelFieldMap.put(objName, (String) gcMap.get('relationshipField'));\n                }\n            }\n        }\n\n        // Build child objects list with relationship detection\n        List<Map<String, Object>> childObjects = new List<Map<String, Object>>();\n\n        // Build fields by object from selectedFieldsRaw\n        Map<String, List<String>> fieldsByObject = new Map<String, List<String>>();\n        for (String objectName : selectedFieldsRaw.keySet()) {\n            List<Object> fieldsRaw = (List<Object>) selectedFieldsRaw.get(objectName);\n            List<String> fields = new List<String>();\n            for (Object field : fieldsRaw) {\n                fields.add(String.valueOf(field));\n            }\n            // CRITICAL: Skip objects that have no meaningful fields.\n            // Prevents creating DCM details that provide no context (e.g., objects with only Id / *Id fields).\n            if (objectName != rootObject && !hasMinimumMeaningfulFields(fields)) {\n                continue;\n            }\n            fieldsByObject.put(objectName, fields);\n        }\n\n        // Build child objects ONLY from selectedFields (objects that actually have usable context).\n        // This mirrors the shell script behavior: Stage 4 filters to non-empty objects, and DCM config\n        // should not include empty/low-signal objects.\n        Set<String> processedObjects = new Set<String>();\n        Set<String> skippedObjects = new Set<String>();\n\n        // First, add objects from selectedFieldsRaw (they have fields selected)\n        for (String objectName : selectedFieldsRaw.keySet()) {\n            if (objectName != rootObject && !processedObjects.contains(objectName)) {\n                // Skip if Stage 5 produced only ID-like fields (no meaningful context)\n                if (!fieldsByObject.containsKey(objectName)) {\n                    skippedObjects.add(objectName);\n                    continue;\n                }\n                Map<String, Object> childConfig = buildChildObjectConfig(\n                    objectName, rootObject, grandchildObjectNames,\n                    grandchildParentMap, grandchildRelFieldMap);\n\n                // Only add if valid relationship exists (buildChildObjectConfig returns null if not)\n                if (childConfig != null) {\n                    childObjects.add(childConfig);\n                    processedObjects.add(objectName);\n                } else {\n                    skippedObjects.add(objectName);\n                }\n            }\n        }\n\n        // Log skipped objects for debugging\n        if (!skippedObjects.isEmpty()) {\n            System.debug('Stage8: Skipped objects without valid relationships: ' + skippedObjects);\n        }\n\n        return new Map<String, Object>{\n            'name' => promptName + ' DCM',\n            'rootObject' => rootObject,\n            'childObjects' => childObjects,\n            'fieldsByObject' => fieldsByObject\n        };\n    }\n\n    /**\n     * @description Builds configuration for a single child object\n     * @param objectName Name of the child object\n     * @param rootObject Name of the root object\n     * @param grandchildObjectNames Set of grandchild object names\n     * @param grandchildParentMap Map of grandchild to parent object\n     * @param grandchildRelFieldMap Map of grandchild to relationship field\n     * @return Configuration map for the child object\n     */\n    private Map<String, Object> buildChildObjectConfig(\n            String objectName,\n            String rootObject,\n            Set<String> grandchildObjectNames,\n            Map<String, String> grandchildParentMap,\n            Map<String, String> grandchildRelFieldMap) {\n\n        // Determine the parent for this object (root or intermediate parent for grandchildren)\n        String parentForRelationship = rootObject;\n        Boolean isGrandchild = grandchildObjectNames.contains(objectName);\n        if (isGrandchild) {\n            parentForRelationship = grandchildParentMap.get(objectName);\n        }\n\n        // Get the ACTUAL relationship name from Salesforce schema\n        String actualRelationshipName = getChildRelationshipName(objectName, parentForRelationship);\n\n        // If no valid relationship found, return null to skip this object\n        if (String.isBlank(actualRelationshipName)) {\n            System.debug('Stage8: Skipping object ' + objectName + ' - no valid relationship to ' + parentForRelationship);\n            return null;\n        }\n\n        Map<String, Object> childConfig = new Map<String, Object>{\n            'objectName' => objectName,\n            'relationshipName' => actualRelationshipName,\n            'maxRecords' => 10\n        };\n\n        // Check if this is a grandchild (has parentObject)\n        if (isGrandchild) {\n            childConfig.put('parentObject', grandchildParentMap.get(objectName));\n            childConfig.put('relationshipField', grandchildRelFieldMap.get(objectName));\n        } else {\n            // Direct child - relationship to root\n            childConfig.put('relationshipField', getRelationshipField(objectName, rootObject));\n        }\n\n        return childConfig;\n    }\n\n    /**\n     * @description Gets the relationship field for a child object to the parent\n     * @param childObject The child object API name\n     * @param parentObject The parent object API name\n     * @return The relationship field name (e.g., AccountId)\n     */\n    private String getRelationshipField(String childObject, String parentObject) {\n        // Use DCMBuilder's auto-detection if available\n        DCMBuilder.RelationshipDetectionResult detection =\n            DCMBuilder.detectRelationshipField(childObject, parentObject);\n        if (detection != null) {\n            return detection.relationshipField;\n        }\n\n        // Fallback to standard pattern\n        return parentObject + 'Id';\n    }\n\n    /**\n     * @description Gets the ACTUAL child relationship name from Salesforce schema\n     * @param childObject The child object API name\n     * @param parentObject The parent object API name\n     * @return The relationship name from schema, or null if no valid relationship exists\n     */\n    private String getChildRelationshipName(String childObject, String parentObject) {\n        // Get actual relationship name from Salesforce schema\n        List<SchemaHelper.ChildRelationship> childRels = SchemaHelper.getChildRelationships(parentObject);\n\n        for (SchemaHelper.ChildRelationship rel : childRels) {\n            if (rel.childObject == childObject && String.isNotBlank(rel.relationshipName)) {\n                return rel.relationshipName;\n            }\n        }\n\n        // Return null if no valid relationship found - caller should handle this\n        return null;\n    }\n\n    /**\n     * @description Checks if a child object has a valid queryable relationship to the parent\n     * @param childObject The child object API name\n     * @param parentObject The parent object API name\n     * @return true if a valid relationship exists\n     */\n    private Boolean hasValidRelationship(String childObject, String parentObject) {\n        List<SchemaHelper.ChildRelationship> childRels = SchemaHelper.getChildRelationships(parentObject);\n\n        for (SchemaHelper.ChildRelationship rel : childRels) {\n            if (rel.childObject == childObject && String.isNotBlank(rel.relationshipName)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @description Returns true if the object has minimum meaningful fields.\n     * \"Meaningful\" excludes Id and all *Id / *ById fields, since those do not provide LLM context.\n     */\n    private Boolean hasMinimumMeaningfulFields(List<String> fields) {\n        if (fields == null || fields.isEmpty()) {\n            return false;\n        }\n        Integer meaningful = 0;\n        for (String f : fields) {\n            if (String.isBlank(f)) continue;\n            if (f == 'Id') continue;\n            if (f.endsWith('Id')) continue;\n            if (f.endsWith('ById')) continue;\n            meaningful++;\n        }\n        // Keep this aligned with Stage05_FieldSelection.MIN_MEANINGFUL_FIELDS\n        return meaningful >= 3;\n    }\n\n    /**\n     * @description Builds Prompt configuration for Stage 9\n     * @param rootObject The root Salesforce object\n     * @param aiInstructions AI instructions section\n     * @param htmlTemplate HTML template with merge fields\n     * @param groundingRules Grounding rules for AI behavior\n     * @param inputs Full inputs for additional context\n     * @return Map with Prompt configuration\n     */\n    private Map<String, Object> buildPromptConfigForStage9(\n            String rootObject,\n            String aiInstructions,\n            String htmlTemplate,\n            String groundingRules,\n            Map<String, Object> inputs) {\n\n        // Get prompt name from run record or inputs\n        String promptName = (String) inputs.get('promptName');\n        if (String.isBlank(promptName)) {\n            promptName = rootObject + ' Summary';\n        }\n\n        String businessContext = (String) inputs.get('businessContext');\n\n        return new Map<String, Object>{\n            'name' => promptName,\n            'label' => promptName,\n            'description' => 'Auto-generated prompt for ' + rootObject + '. ' +\n                           (String.isNotBlank(businessContext) ? businessContext.left(200) : ''),\n            'promptCommand' => aiInstructions,\n            'htmlTemplate' => htmlTemplate,\n            'groundingRules' => groundingRules,\n            'targetObject' => rootObject,\n            'promptType' => 'Text',\n            'modelName' => 'claude-sonnet-4.5',\n            'maxTokens' => 4096,\n            'temperature' => 1.0\n        };\n    }\n\n    /**\n     * @description Custom exception for stage errors\n     */\n    public class StageException extends Exception {}\n}"
      }
    ],
    "totalSize": 1,
    "done": true
  },
  "warnings": []
}
