# V2.2 Design Specifications

## Task 2.5: Field Density Profiling Design

**Author:** Opus
**Status:** Design Complete
**Implementer:** Sonnet (Tasks 2.6, 2.7, 2.8)

### Goal

Calculate what percentage of records have non-null values for each field, so the LLM can prioritize fields that actually contain data.

### Design Decision: Where to Put It

**Recommendation: New method in SchemaHelper**

Rationale:
- Stage 4 is about counting RECORDS per object, not analyzing FIELDS
- SchemaHelper already has field metadata logic
- Keeps density calculation reusable across stages
- Avoids bloating Stage 4 which is already complex

### New Method Signature

```apex
/**
 * @description Calculates field population density by querying sample records
 * @param objectName The object to analyze
 * @param sampleSize Number of records to query (default 100)
 * @return Map of fieldName -> usagePercent (0-100)
 */
public static Map<String, Integer> calculateFieldDensity(String objectName, Integer sampleSize)
```

### Algorithm

```
1. Get list of queryable fields for object (use existing getFields())
2. Build dynamic SOQL: SELECT field1, field2, ... FROM Object LIMIT sampleSize
3. Execute query
4. For each record:
   - For each field:
     - If value != null AND value != '' → increment count for that field
5. Calculate percentage: (count / totalRecords) * 100
6. Return Map<fieldName, percentage>
```

### Governor Limit Considerations

| Limit | Value | Mitigation |
|-------|-------|------------|
| SOQL queries | 100/transaction | Only 1 query per object |
| SOQL rows | 50,000 | sampleSize capped at 500 max |
| Heap size | 6MB sync | Query only needed fields, process in batches if needed |
| Query length | 20,000 chars | Limit to 50 fields per query, batch if needed |

### Implementation Notes for Sonnet

1. **Task 2.6: Implement the method**
   ```apex
   public static Map<String, Integer> calculateFieldDensity(String objectName, Integer sampleSize) {
       // Cap sample size
       Integer maxSample = Math.min(sampleSize != null ? sampleSize : 100, 500);

       // Get queryable fields
       List<FieldMetadata> fields = getFields(objectName);

       // Build field list (limit to 50 to avoid query length issues)
       List<String> fieldNames = new List<String>();
       for (FieldMetadata f : fields) {
           if (fieldNames.size() >= 50) break;
           if (f.isAccessible && isQueryableType(f.type)) {
               fieldNames.add(f.name);
           }
       }

       // Query records
       String soql = 'SELECT ' + String.join(fieldNames, ', ') +
                     ' FROM ' + objectName + ' LIMIT ' + maxSample;
       List<SObject> records = Database.query(soql);

       // Count non-null values
       Map<String, Integer> counts = new Map<String, Integer>();
       for (String fn : fieldNames) counts.put(fn, 0);

       for (SObject rec : records) {
           for (String fn : fieldNames) {
               Object val = rec.get(fn);
               if (val != null && String.valueOf(val) != '') {
                   counts.put(fn, counts.get(fn) + 1);
               }
           }
       }

       // Convert to percentages
       Map<String, Integer> density = new Map<String, Integer>();
       Integer total = records.size();
       if (total > 0) {
           for (String fn : counts.keySet()) {
               density.put(fn, (counts.get(fn) * 100) / total);
           }
       }

       return density;
   }

   private static Boolean isQueryableType(String fieldType) {
       // Exclude blob, address, location compound types
       Set<String> nonQueryable = new Set<String>{'BASE64', 'ADDRESS', 'LOCATION'};
       return !nonQueryable.contains(fieldType.toUpperCase());
   }
   ```

2. **Task 2.7: usagePercent already added to FieldMetadata** (done in Phase 2A)

3. **Task 2.8: Integration point**
   - Call `calculateFieldDensity()` in Stage 5 before building the LLM prompt
   - Merge results into FieldMetadata objects
   - Pass enriched metadata to prompt builder

### Testing

```apex
// Test script
Map<String, Integer> density = SchemaHelper.calculateFieldDensity('Opportunity', 100);
System.debug('Field density for Opportunity:');
for (String field : density.keySet()) {
    System.debug(field + ': ' + density.get(field) + '%');
}
```

---

## Task 2.9: Parent Field Resolution Architecture

**Author:** Opus
**Status:** Design Complete
**Implementer:** Sonnet (Tasks 2.10, 2.11, 2.12)

### Goal

Enable parent fields like `Owner.Name` or `Account.Industry` to be included in the DCM and resolved in the final prompt output.

### Current State Analysis

**DCMBuilder creates:**
- `ccai__AI_Data_Extraction_Field__c` records with:
  - `ccai__Field__c` = field API name (e.g., "Name", "Amount")
  - `ccai__Object__c` = object API name (e.g., "Opportunity")

**GPTfy merge field syntax:**
- Direct field: `{{{Name}}}`
- Child collection: `{{#Contacts}}{{{Name}}}{{/Contacts}}`

### Design Options

#### Option A: Dot Notation in Field Name (Recommended)

Store parent fields with dot notation in `ccai__Field__c`:

```
ccai__Field__c = "Owner.Name"
ccai__Object__c = "Opportunity"
```

**Pros:**
- Simple, intuitive
- May already be supported by GPTfy (needs verification)
- No schema changes needed

**Cons:**
- Requires GPTfy to support this syntax (unknown)

#### Option B: Separate Parent Object Configuration

Add parent objects as separate "PARENT" type in DCM details.

**Pros:**
- Explicit relationship modeling
- More control

**Cons:**
- More complex
- May require GPTfy platform changes

### Recommended Approach

**Start with Option A** - test if GPTfy supports dot notation. The implementation should:

1. **Task 2.10: Update DCMBuilder**

   Add new method to create parent field records:
   ```apex
   private static SObject createParentFieldRecord(
       Id dcmId,
       String lookupField,      // e.g., "OwnerId"
       String parentObject,     // e.g., "User"
       String parentField,      // e.g., "Name"
       String sourceObject,     // e.g., "Opportunity"
       Integer sequence
   ) {
       // Determine the relationship name (e.g., "Owner" from "OwnerId")
       String relationshipName = lookupField.removeEnd('Id');
       String fieldPath = relationshipName + '.' + parentField;  // "Owner.Name"

       SObject field = newSObject('ccai__AI_Data_Extraction_Field__c');
       field.put('ccai__AI_Data_Extraction_Mapping__c', dcmId);
       field.put('ccai__Type__c', 'FIELD');
       field.put('ccai__Field__c', fieldPath);  // "Owner.Name"
       field.put('ccai__Object__c', sourceObject);  // "Opportunity"
       field.put('ccai__Label__c', relationshipName + ' ' + parentField);  // "Owner Name"
       field.put('ccai__Send_To_AI__c', true);
       return field;
   }
   ```

2. **Task 2.11: Update Stage 8**

   Pass `selectedParentFields` from Stage 5 output to DCM creation:
   ```apex
   // In Stage 8 or Stage 9 where DCM is created
   Map<String, List<String>> selectedParentFields =
       (Map<String, List<String>>) inputs.get('selectedParentFields');

   // For each object's parent fields
   for (String objectName : selectedParentFields.keySet()) {
       for (String parentFieldPath : selectedParentFields.get(objectName)) {
           // Parse "OwnerId.Name" -> lookupField="OwnerId", parentField="Name"
           List<String> parts = parentFieldPath.split('\\.');
           String lookupField = parts[0];  // "OwnerId"
           String parentField = parts[1];  // "Name"

           // Get parent object from lookup field
           String parentObject = getParentObjectFromLookup(objectName, lookupField);

           // Add to DCM
           fieldsToInsert.add(createParentFieldRecord(
               dcmId, lookupField, parentObject, parentField, objectName, sequence++
           ));
       }
   }
   ```

3. **Task 2.12: Update merge field reference**

   In `Stage08_PromptAssembly.buildMergeFieldReference()`, include parent fields:
   ```apex
   // After listing regular fields, add parent fields
   if (selectedParentFields != null && selectedParentFields.containsKey(objectName)) {
       ref += '\nPARENT FIELDS (via lookup):\n';
       for (String parentPath : selectedParentFields.get(objectName)) {
           // Convert "OwnerId.Name" to "{{{Owner.Name}}}"
           String mergePath = parentPath.replace('Id.', '.');
           ref += '- {{{' + mergePath + '}}} (' + parentPath + ')\n';
       }
   }
   ```

### Data Flow

```
Stage 5 (Field Selection)
    ↓ selectedParentFields: {"Opportunity": ["OwnerId.Name", "AccountId.Industry"]}
Stage 8 (Prompt Assembly)
    ↓ Include in merge field reference
Stage 9 (Create & Deploy)
    ↓ Create DCM field records with "Owner.Name", "Account.Industry"
GPTfy Runtime
    ↓ Resolve {{{Owner.Name}}} to actual user name
Final Output
    → "Assigned to Sarah Johnson" instead of "Assigned to the owner"
```

### Verification Required

Before implementing, Sonnet should verify:

1. **Does GPTfy support dot notation in field paths?**
   - Test manually: Create a DCM with `ccai__Field__c = "Owner.Name"`
   - Run a prompt and check if it resolves

2. **If not supported, what's the alternative?**
   - Check GPTfy documentation
   - Check if there's a `ccai__Parent_Field__c` or similar

### Testing

```apex
// Create test DCM with parent field
DCMBuilder.DCMConfig config = new DCMBuilder.DCMConfig();
config.name = 'Test Parent Fields';
config.rootObject = 'Opportunity';
config.fieldsByObject.put('Opportunity', new List<String>{'Name', 'Amount', 'Owner.Name'});
Id dcmId = DCMBuilder.createDCM(config);

// Query and verify
List<SObject> fields = [SELECT ccai__Field__c FROM ccai__AI_Data_Extraction_Field__c
                        WHERE ccai__AI_Data_Extraction_Mapping__c = :dcmId];
for (SObject f : fields) {
    System.debug('Field: ' + f.get('ccai__Field__c'));
}
```

---

## Summary

| Task | Design | Implementer | Dependencies |
|------|--------|-------------|--------------|
| 2.5 | Complete | Opus | None |
| 2.6 | Spec above | Sonnet | 2.5 |
| 2.7 | Already done | - | Phase 2A |
| 2.8 | Spec above | Sonnet | 2.6 |
| 2.9 | Complete | Opus | None |
| 2.10 | Spec above | Sonnet | 2.9 |
| 2.11 | Spec above | Sonnet | 2.9 |
| 2.12 | Spec above | Sonnet | 2.9 |

Sonnet can now proceed with implementation based on these specs.
