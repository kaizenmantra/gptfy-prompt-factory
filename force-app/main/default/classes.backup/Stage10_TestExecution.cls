/**
 * @description Stage 10: Test Execution - Readiness Checker
 *
 * This stage implements the "Clean Callout" architecture to resolve DML/callout conflicts.
 * It performs a non-blocking readiness check and delegates actual execution to Stage10_RestCalloutJob.
 *
 * ARCHITECTURE:
 * - Stage10_TestExecution: Checks if prompt is ready (Active + has Prompt Request ID + Backend Ready)
 * - Stage10_TestExecutionJob: Orchestrates retries vs callout handoff
 * - Stage10_RestCalloutJob: Performs DML-free REST callout to GPTfy
 * - Stage10_RetryHandler: Schedules delayed retries (20-second intervals)
 *
 * RETURN STATUSES:
 * - 'Retry': Prompt not ready yet, job should re-enqueue after delay
 * - 'ReadyForCallout': Prompt is ready, Stage10_RestCalloutJob should execute
 * - 'Failed': Unrecoverable error (missing prompt, activation failure)
 *
 * CRITICAL: This stage uses Prompt Request Id (ccai__Prompt_Request_Id__c) for execution,
 * NOT the Prompt record Id. The Prompt Request Id is generated by GPTfy during activation.
 *
 * TIMING ISSUE FIX (Jan 2026):
 * GPTfy has a multi-phase activation process:
 * 1. Status = 'Active' (immediate)
 * 2. Prompt Request ID generated (2-30 seconds)
 * 3. Backend processing/compilation (VARIABLE - can take 30-60+ seconds)
 *
 * This stage now adds a MINIMUM WAIT TIME after Prompt Request ID is captured
 * to allow GPTfy's backend to complete processing before attempting execution.
 */
public with sharing class Stage10_TestExecution implements IStage {

    private static final Integer STAGE_NUMBER = 10;

    // TIMING FIX: Minimum wait time (in seconds) after Prompt Request ID is generated
    // before attempting execution. This allows GPTfy's backend to complete processing.
    // Configurable via Custom Metadata in future; hardcoded for now based on testing.
    //
    // With the re-activation cycle in Stage 9, we can use a shorter wait time.
    // The re-activation forces GPTfy to fully register the prompt.
    private static final Integer MIN_WAIT_AFTER_ACTIVATION_SECONDS = 30;

    /**
     * @description Performs readiness check for Stage 10: Test Execution
     *
     * This method checks if the prompt is ready for execution (Active status + Prompt Request ID).
     * If not ready, it returns 'Retry' status for the job to re-enqueue.
     * If ready, it returns 'ReadyForCallout' and the job hands off to Stage10_RestCalloutJob.
     *
     * @param runId ID of the PF_Run__c record
     * @param inputs Map containing promptId, sampleRecordId from previous stages
     * @return StageResult with execution status ('Retry', 'ReadyForCallout', or 'Failed')
     */
    public StageResult execute(Id runId, Map<String, Object> inputs) {
        StageResult result = new StageResult('Stage 10: Test Execution');
        
        try {
            // Extract inputs
            Id promptId = (Id) inputs.get('promptId');
            String promptRequestId = (String) inputs.get('promptRequestId');

            if (promptId == null) {
                throw new StageException('Prompt ID is required');
            }

            // PHASE 1: READINESS CHECK (Non-blocking)
            System.debug('Stage10: Checking prompt readiness for Prompt Id: ' + promptId);
            
            List<ccai__AI_Prompt__c> prompts = [
                SELECT Id, ccai__Prompt_Request_Id__c, ccai__Status__c, ccai__Message__c
                FROM ccai__AI_Prompt__c
                WHERE Id = :promptId
                LIMIT 1
            ];

            if (prompts.isEmpty()) {
                throw new StageException('Prompt not found: ' + promptId);
            }

            ccai__AI_Prompt__c prompt = prompts[0];
            String status = prompt.ccai__Status__c;
            String reqId = prompt.ccai__Prompt_Request_Id__c;

            // Check for activation errors
            if (String.isNotBlank(prompt.ccai__Message__c)) {
                String msg = prompt.ccai__Message__c.toLowerCase();
                if (msg.contains('error') || msg.contains('failed')) {
                    throw new StageException('Prompt activation failed on GPTfy side: ' + prompt.ccai__Message__c);
                }
            }

            // Phase 1.5: Pass through critical metadata for downstream consumption (even if retrying)
            result.outputs.put('promptId', promptId);
            result.outputs.put('sampleRecordId', inputs.get('sampleRecordId'));
            result.outputs.put('rootObject', inputs.get('rootObject'));
            result.outputs.put('dcmId', inputs.get('dcmId'));

            // If not Active or no Request ID, tell the job to retry later
            if (status != 'Active' || String.isBlank(reqId)) {
                System.debug('Stage10: Prompt not ready yet. Status: ' + status + ', ID: ' + (String.isBlank(reqId) ? 'Missing' : 'Present'));
                result.status = 'Retry'; // Custom status for the Job to handle
                return result;
            }

            // PHASE 2: TIMING CHECK - Wait for GPTfy backend processing
            // CRITICAL FIX: Even though Prompt Request ID exists, GPTfy's backend may still be
            // processing/compiling/indexing the prompt. We need to wait a minimum amount of time
            // after the prompt was activated before attempting execution.

            // Get activation timestamp from inputs (set by Stage 9)
            Long activationTimestamp = (Long) inputs.get('activationTimestamp');
            if (activationTimestamp == null) {
                // Fallback: Use current time minus a buffer (assume just activated)
                // This ensures we wait at least MIN_WAIT_AFTER_ACTIVATION_SECONDS
                activationTimestamp = System.currentTimeMillis() - (MIN_WAIT_AFTER_ACTIVATION_SECONDS * 1000);
                System.debug('Stage10: No activation timestamp found, using fallback');
            }

            Long currentTime = System.currentTimeMillis();
            Long elapsedSeconds = (currentTime - activationTimestamp) / 1000;

            if (elapsedSeconds < MIN_WAIT_AFTER_ACTIVATION_SECONDS) {
                Long remainingSeconds = MIN_WAIT_AFTER_ACTIVATION_SECONDS - elapsedSeconds;
                System.debug('Stage10: Prompt Request ID exists but only ' + elapsedSeconds +
                    's since activation. Waiting ' + remainingSeconds + 's more for GPTfy backend processing.');
                PromptFactoryLogger.info(runId, STAGE_NUMBER,
                    'Prompt Request ID captured but waiting for GPTfy backend processing. ' +
                    'Elapsed: ' + elapsedSeconds + 's, Required: ' + MIN_WAIT_AFTER_ACTIVATION_SECONDS + 's');
                result.status = 'Retry'; // Continue retrying until minimum wait time passes
                return result;
            }

            // PHASE 3: INITIATE CLEAN CALLOUT
            // Prompt Request ID exists AND sufficient time has passed for GPTfy backend processing
            // Instead of executing here (to avoid DML before callout), we return 'ReadyForCallout'
            // and the Job starts a fresh, DML-free transaction for the REST callout.
            // NOTE: We do NOT call markCompleted() here because the Job checks for 'ReadyForCallout' status.
            result.outputs.put('promptRequestId', reqId);
            result.status = 'ReadyForCallout';

            PromptFactoryLogger.info(runId, STAGE_NUMBER,
                'Prompt is ready for execution (' + elapsedSeconds + 's since activation). Handing off to Clean Callout Job.');

        } catch (Exception e) {
            result.markFailed('Failed in readiness check: ' + e.getMessage());
            PromptFactoryLogger.logException(runId, STAGE_NUMBER, 'Stage execution failed', e);
        }

        return result;
    }

    /**
     * @description Custom exception for stage errors
     */
    public class StageException extends Exception {}
}