{
  "status": 0,
  "result": {
    "records": [
      {
        "attributes": {
          "type": "ApexClass",
          "url": "/services/data/v65.0/tooling/sobjects/ApexClass/01pQH00000HfbbsYAB"
        },
        "Body": "/**\n * @description Shared utility class for Stage Job classes\n * Provides consistent sanitization, size checking, and serialization\n * across all pipeline Job classes (Stage05-12).\n *\n * STACK OVERFLOW PREVENTION:\n * This class centralizes the sanitization logic to ensure all Job classes\n * handle large data structures safely without causing stack depth errors.\n */\npublic class StageJobHelper {\n\n    // Constants for sanitization limits\n    private static final Integer MAX_SANITIZE_DEPTH = 5;\n    private static final Integer MAX_LIST_ITEMS = 200;\n    private static final Integer MAX_STRING_LEN = 5000;\n    private static final Integer MAX_OUTPUT_JSON_SIZE = 130000;\n\n    // Keys that should be omitted to prevent stack overflow\n    private static final Set<String> KEY_DENYLIST = new Set<String>{\n        'recordData', 'recordDataJson',\n        'fullRecord', 'fullRecordJson',\n        'dataAvailability', 'allFieldsMetadata',\n        'rawFieldsByObject', 'candidateFieldsRaw'\n    };\n\n    /**\n     * @description Safely serializes stage outputs for storage\n     * Includes size checking, sanitization, and truncation\n     * @param outputs Map of stage outputs to serialize\n     * @return JSON string safe for storage in Output_Data__c\n     */\n    public static String serializeOutputs(Map<String, Object> outputs) {\n        if (outputs == null || outputs.isEmpty()) {\n            return '{}';\n        }\n\n        try {\n            // First, estimate size to avoid unnecessary processing\n            String rawJson = JSON.serialize(outputs);\n            if (rawJson.length() <= MAX_OUTPUT_JSON_SIZE) {\n                return rawJson;\n            }\n\n            // Size exceeds limit - sanitize to reduce size\n            Map<String, Object> sanitized = sanitizeMapForStorage(outputs, 0);\n            String sanitizedJson = JSON.serialize(sanitized);\n\n            // Truncate if still too large\n            if (sanitizedJson.length() > MAX_OUTPUT_JSON_SIZE) {\n                return truncateJson(sanitizedJson, MAX_OUTPUT_JSON_SIZE);\n            }\n\n            return sanitizedJson;\n\n        } catch (Exception e) {\n            // Serialization failed - return error indicator\n            return '{\"serializationError\": true, \"message\": \"' +\n                String.valueOf(e.getMessage()).replace('\"', '\\\\\"').left(200) + '\"}';\n        }\n    }\n\n    /**\n     * @description Sanitizes a map for safe JSON serialization/storage\n     * Prevents stack depth errors from deep/recursive structures\n     * @param source Source map to sanitize\n     * @param depth Current recursion depth\n     * @return Sanitized map safe for serialization\n     */\n    public static Map<String, Object> sanitizeMapForStorage(Map<String, Object> source, Integer depth) {\n        Map<String, Object> out = new Map<String, Object>();\n\n        if (source == null) {\n            return out;\n        }\n\n        if (depth >= MAX_SANITIZE_DEPTH) {\n            out.put('_note', '[DEPTH_LIMIT_REACHED]');\n            return out;\n        }\n\n        for (String key : source.keySet()) {\n            // Skip denylisted keys\n            if (KEY_DENYLIST.contains(key)) {\n                out.put(key, '[OMITTED_LARGE_DATA]');\n                continue;\n            }\n\n            Object value = source.get(key);\n            out.put(key, sanitizeValueForStorage(value, depth + 1));\n        }\n\n        return out;\n    }\n\n    /**\n     * @description Sanitizes an arbitrary value for safe JSON serialization\n     * @param value Value to sanitize\n     * @param depth Current recursion depth\n     * @return Sanitized value\n     */\n    public static Object sanitizeValueForStorage(Object value, Integer depth) {\n        if (value == null) {\n            return null;\n        }\n\n        if (depth >= MAX_SANITIZE_DEPTH) {\n            return '[DEPTH_LIMIT_REACHED]';\n        }\n\n        // Preserve primitives with size limits\n        if (value instanceof String) {\n            String s = (String) value;\n            return s.length() > MAX_STRING_LEN\n                ? s.substring(0, MAX_STRING_LEN - 3) + '...'\n                : s;\n        }\n\n        if (value instanceof Boolean || value instanceof Integer ||\n            value instanceof Long || value instanceof Decimal ||\n            value instanceof Double) {\n            return value;\n        }\n\n        if (value instanceof Date) {\n            return ((Date) value).format();\n        }\n\n        if (value instanceof DateTime) {\n            return ((DateTime) value).format();\n        }\n\n        if (value instanceof Time) {\n            return String.valueOf((Time) value);\n        }\n\n        if (value instanceof Id) {\n            return (String) value;\n        }\n\n        // Handle nested maps\n        if (value instanceof Map<String, Object>) {\n            return sanitizeMapForStorage((Map<String, Object>) value, depth);\n        }\n\n        // Handle lists with item limits\n        if (value instanceof List<Object>) {\n            List<Object> src = (List<Object>) value;\n            List<Object> out = new List<Object>();\n\n            Integer itemLimit = Math.min(src.size(), MAX_LIST_ITEMS);\n            for (Integer i = 0; i < itemLimit; i++) {\n                out.add(sanitizeValueForStorage(src[i], depth + 1));\n            }\n\n            if (src.size() > MAX_LIST_ITEMS) {\n                out.add('[TRUNCATED:' + (src.size() - MAX_LIST_ITEMS) + '_items]');\n            }\n\n            return out;\n        }\n\n        // SObjects can create deep graphs - extract ID only\n        if (value instanceof SObject) {\n            SObject sob = (SObject) value;\n            try {\n                Object sobId = sob.get('Id');\n                return sobId != null ? String.valueOf(sobId) : '[SObject_NO_ID]';\n            } catch (Exception e) {\n                return '[SObject]';\n            }\n        }\n\n        // Blobs are not safe for logs\n        if (value instanceof Blob) {\n            return '[BLOB_OMITTED]';\n        }\n\n        // Fallback: stringified representation\n        String stringVal = String.valueOf(value);\n        return stringVal.length() > MAX_STRING_LEN\n            ? stringVal.substring(0, MAX_STRING_LEN - 3) + '...'\n            : stringVal;\n    }\n\n    /**\n     * @description Truncates JSON string while trying to keep it valid\n     * @param jsonStr JSON string to truncate\n     * @param maxLength Maximum allowed length\n     * @return Truncated JSON string\n     */\n    public static String truncateJson(String jsonStr, Integer maxLength) {\n        if (jsonStr == null) {\n            return '{}';\n        }\n\n        if (jsonStr.length() <= maxLength) {\n            return jsonStr;\n        }\n\n        // Truncate and add indicator that JSON is incomplete\n        return jsonStr.substring(0, maxLength - 25) + '...\"_truncated\": true}';\n    }\n\n    /**\n     * @description Truncates a string to maximum length with ellipsis\n     * @param str String to truncate\n     * @param maxLength Maximum length\n     * @return Truncated string\n     */\n    public static String truncate(String str, Integer maxLength) {\n        if (str == null) {\n            return null;\n        }\n\n        if (str.length() <= maxLength) {\n            return str;\n        }\n\n        return str.substring(0, maxLength - 3) + '...';\n    }\n\n    /**\n     * @description Loads inputs from a previous stage with error handling\n     * @param runId The PF_Run__c record ID\n     * @param previousStageNumber The stage number to load inputs from\n     * @return Map of input data, empty map if not found\n     */\n    public static Map<String, Object> loadInputsFromStage(Id runId, Integer previousStageNumber) {\n        List<PF_Run_Stage__c> stages = [\n            SELECT Output_Data__c\n            FROM PF_Run_Stage__c\n            WHERE Run__c = :runId AND Stage_Number__c = :previousStageNumber\n            ORDER BY CreatedDate DESC\n            LIMIT 1\n        ];\n\n        if (stages.isEmpty() || String.isBlank(stages[0].Output_Data__c)) {\n            return new Map<String, Object>();\n        }\n\n        try {\n            Object parsed = JSON.deserializeUntyped(stages[0].Output_Data__c);\n            if (parsed instanceof Map<String, Object>) {\n                return (Map<String, Object>) parsed;\n            }\n            return new Map<String, Object>();\n        } catch (Exception e) {\n            System.debug(LoggingLevel.ERROR,\n                'Failed to parse stage ' + previousStageNumber + ' outputs: ' + e.getMessage());\n            return new Map<String, Object>();\n        }\n    }\n\n    /**\n     * @description Creates and inserts a PF_Run_Stage__c record with sanitized data\n     * @param runId The PF_Run__c record ID\n     * @param stageNumber Stage number (1-12)\n     * @param result StageResult from execution\n     */\n    public static void saveStageResult(Id runId, Integer stageNumber, StageResult result) {\n        String outputsJson = serializeOutputs(result.outputs);\n\n        PF_Run_Stage__c stageRecord = new PF_Run_Stage__c(\n            Run__c = runId,\n            Stage_Number__c = stageNumber,\n            Stage_Name__c = result.stageName,\n            Status__c = result.status,\n            Input_Data__c = '{}',  // Inputs stored on previous stage's output\n            Output_Data__c = outputsJson,\n            AI_Reasoning__c = truncate(result.aiReasoning, 32000),\n            Error_Message__c = truncate(result.errorMessage, 5000),\n            Started_At__c = result.startedAt,\n            Completed_At__c = System.now(),\n            Duration_Seconds__c = result.getDurationSeconds()\n        );\n\n        insert stageRecord;\n\n        // Bulk insert logs if any\n        if (result.logs != null && !result.logs.isEmpty()) {\n            insert result.logs;\n        }\n    }\n\n    /**\n     * @description Updates the current stage progress on the run record\n     * @param runId The PF_Run__c record ID\n     * @param stageNumber Current stage number\n     */\n    public static void updateProgress(Id runId, Integer stageNumber) {\n        PF_Run__c run = [SELECT Id FROM PF_Run__c WHERE Id = :runId LIMIT 1];\n        run.Current_Stage__c = stageNumber;\n        update run;\n    }\n\n    /**\n     * @description Marks a run as failed with an error message\n     * @param runId The PF_Run__c record ID\n     * @param errorMsg Error message to store\n     */\n    public static void markRunFailed(Id runId, String errorMsg) {\n        try {\n            PF_Run__c run = [SELECT Id FROM PF_Run__c WHERE Id = :runId LIMIT 1];\n            run.Status__c = 'Failed';\n            run.Error_Message__c = truncate(errorMsg, 5000);\n            update run;\n        } catch (Exception e) {\n            System.debug(LoggingLevel.ERROR,\n                'Failed to mark run as failed: ' + e.getMessage());\n        }\n    }\n\n    /**\n     * @description Checks if a stage result indicates success\n     * @param result StageResult to check\n     * @return True if stage completed successfully or with warning\n     */\n    public static Boolean isStageSuccess(StageResult result) {\n        return result != null &&\n            (result.status == 'Completed' || result.status == 'Warning');\n    }\n}"
      }
    ],
    "totalSize": 1,
    "done": true
  },
  "warnings": []
}
